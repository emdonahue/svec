#!/bin/zsh

#TODO add flags to help menu

set -o errexit
set -o pipefail
if [[ "${TRACE-0}" == "1" ]]; then set -o xtrace; fi

zparseopts -A opts -E -D g:=opts
local PRECISION=${opts[-g]:-17} #Sets the decimal precision of numeric calculations.
export LC_COLLATE=${opts[-l]:-C} #Selects the locale for determining sort order of dimensions.

local US=$'\037'

svecawk() {
    #3.322 is approximate bits of precision needed per decimal digit, per awk manual.
    awk -M -vPREC=$((3.322 * $PRECISION)) -vCONVFMT="%.${PRECISION}g" -vOFMT="%.${PRECISION}g" "$@"
}

arithmetic() {
    svecawk -F'\t' -vOFS=$'\t' '{while (2<NF) {$2'"$1"'=$NF; NF--}; print}'
}

CMD="$1"
[[ $# -ne 0 ]] && shift
case "$CMD" in
    add) #Element-wise sum of 2 or more vectors
	#<vector> [<vector>]
	"$0" join "$@" | arithmetic "+" | "$0" sparse
	;;
    analogy) #Computes the analogy vector from 3 word2vec embeddings king:man::queen:woman => -king+man+queen=woman
	#<vector> <vector> <vector>
	"$0" add <("$0" negate "$1") "$2" "$3"
	;;
    cooccurrences) #Prints a 2D matrix of counts of token co-occurrence within a given window computed from a whitespace-separated file of tokens
	#<window> <file>
	tr -s '[:space:]' '\n' < "$2" | awk -vW="$1" '$1 { for (i=1;i<=W;i++) { if(c[i]) print (c[i]<$0) ? c[i] FS $0 : $0 FS c[i]; c[i]=c[i+1] }; c[W]=$0; }' | "$0" counts
	;;
    counts) #Prints a vector of counts from a newline-separated stream of tokens
	#<file>
	sort "${1:--}" | uniq -c | sed -E 's/[[:space:]]*([[:digit:]]+) (.+)/\2\t\1/'
	;;
    dot) #Dot product of multiple vectors
	#[<vector>]
	"$0" join "$@" | arithmetic '*' | "$0" sum
	;;
    detriangularize) #Computes a dense 2D matrix from a triangular matrix by copying values across the diagonal
	#<triangular matrix>
	svecawk '{print} $1!=$2 {print $2,$1"\t"$3}' "$1" | sort
	;;
    --help|-h|help) #Print the list of subcommands or help information for a specific subcommand (e.g. "svec help dot")
	#<subcommand>
	{[[ -z "$1" ]] && echo 'usage: svec <subcommand> [arguments] (All subcommands respect the -g flag to specify the decimal precision of arithmetic)';
	 grep -A "${+1}" -- "$1.*)\s#" "$0" | sed -nE -e 's/\s*(.+)\)\s#(.+)$/\1 - \2/p' -e "s/^\s*#(.+)/usage: $1 \1/p"} | \
	    sed 's/^\s*//; 2,$ s/^/\t/'	
	;;
    join) #Concatenates numerical values with the same indices together for further processing (summation, multiplication, etc.). Empty rows are filled with 0, but if multiple vectors are joined, there may be fewer 0s than vectors. 
	#<vector> [<vector>]
	if [[ $# -le 1 ]]; then
	    cat "$1"
	elif [[ $# -eq 2 ]]; then
	    #-e requires -o, which means we must know the number of columns, so we must convert to a different schema
	    join -a1 -a2 -e0 -o 0,1.2,2.2 -t$US <(sed 's/\t/'$'\037''/1' "$1") <(sed 's/\t/'$'\037''/1' "$2") | tr $'\037' '\t'
	else
	    "$0" join "$1" "$2" | {shift 2; "$0" join - "$@"}
	fi
	;;
    negate) #Negates a vector
	#<vector>
	"$0" scale -1 "$1"
	;;
    neighbors) #Accepts a 2D matrix and a vector and outputs a vector of cosine distances between the rows of the matrix and the input vector
	#<2D matrix> <vector>	
	local VEC=$(mktemp --suffix=.svec)
	trap "rm -f $VEC"
	local NORM=$(<"$2" tee "$VEC" | "$0" norm)
	join -a1 -e"0" -o 1.1,0,1.3,2.2 -12 <(sort -k2,2 "${1:--}") "$VEC" | svecawk -vOFS='\t' -vVNORM="$NORM" '{v1=$(NF-1); v2=$NF; NF-=3; if (!d) d=$0; if (d!=$0) {output(); d=$0}; norm+=v1*v1; dot+=v1*v2} END {output()} function output(){ print d,dot/(sqrt(norm)*VNORM); norm=dot=0 }' | "$0" sparse
	;;
    norm) #Computes the Euclidean norm of a vector, or an entry-wise Euclidean norm of a matrix
	#<vector>
	svecawk '{n+=$NF*$NF} END {print sqrt(n)}' "$1"
	;;    
    row) #Filters by rows where the leftmost column matches DIMENSION and returns an N-1 matrix by removing that dimension.
	#DIMENSION MATRIX
	grep -E "^$1 " "${2:--}" | sed -E 's/^[^ ]+ (.*)/\1/'
	;;
    scale) #Scale all elements by a constant
	#<constant> <vector>
	svecawk -F'\t' -vOFS='\t' '{$2*=('"$1"'); print $1,$2}' "$2"
	;;
    sparse) #Removes 0 valued dimensions to create sparse vector or matrix
	#<matrix>
	svecawk -F'\t' -vOFS='\t' '$NF!=0' "$1"
	;;
    sqrt) #Elementwise square root
	#<matrix>
	svecawk -F'\t' -vOFS='\t' '{$2=sqrt($2); print $1,$2}' "$1"
	;;
    square) #Elementwise square
	   #<matrix>
	svecawk -F'\t' -vOFS='\t' '{$2*=$2; print $1,$2}' "$1"
	;;
    sum) #Sums all elements and returns a constant
	#<vector>
	svecawk '{n+=$NF} END {print n}' "$1"
	;;
    vecnorm) #Eliminates the rightmost dimension of a matrix and computes the Euclidean norms to use as values for the remaining indices
	#<matrix>
	"$0" square "${1:--}" | "$0" vecsum | "$0" sqrt
	;;
    vecnormalize) #Normalizes vectors defined by the first N-1 dimension of MATRIX
	#get vec norms: a b_\tx
	#file of vecs: a b_ c\ty
	#join vec norms to vecs: a b c\tx\ty
	#requires that join key be n-1 dims
	local NORMS=$(mktemp --suffix=.svec) VECS=$(mktemp --suffix=.svec)
	trap "rm -f $NORMS $VECS" EXIT
	< "${1:--}" tee >("$0" vecnorm | sed 's/\t/'$'\037''\t/' > "$NORMS") > >(sed -E 's/( [^ ]+\t)/'$'\037''\1/' > "$VECS")
	join -t$'\037' "$VECS" "$NORMS" | arithmetic '/' | tr -d $'\037'
	
	#< "${1:--}" tee  >("$0" vecnorm - | sed 's/\t/'$'\037''x\t/' > "$NORMS") | sed -E 's/( [^ ]+\t)/'$'\037''x\1/' > "$VECS"
	#echo 'cat'
	#cat $NORMS $VECS
	#join -t$'\037' "$VECS" "$NORMS"
	;;
    vecsum) #Eliminates the rightmost dimension of a matrix and computes the sums to use as values for the remaining indices
	#<matrix>
	svecawk -vOFS='\t' '{v=$NF; NF-=2; if (!d) d=$0; if (d!=$0) {printsum(); d=$0}; s+=v} END {printsum()} function printsum(){ print d,s; s=0}' "$1"
	;;
    word2vec) #Computes matrix of log pointwise mutual information scores from the co occurrence matrix of a stream of whitespace-separated tokens that approximates word2vec embeddings
	#<co-occurrence window size> <token file>
	local BIGRAMS=$(mktemp --suffix=.svec) UNIGRAMS=$(mktemp --suffix=.svec)
	trap "rm -f $UNIGRAMS $BIGRAMS" EXIT
	local NUM_UNIGRAMS=$(tr -s '[:space:]' '\n' < "$2" | sed '1 {/^\s*$/d}' | svecawk -vW="$1" -vUs="$0 counts ->$UNIGRAMS" -vBs="$0 counts ->$BIGRAMS" '{print | Us; for (i=1;i<=W;i++) { if(c[i]) { print (c[i]<$0) ? c[i]" "$0 : $0" "c[i] | Bs }; c[i]=c[i+1] }; c[W]=$0 } END {print NR}')
	join -12 <(join "$BIGRAMS" "$UNIGRAMS" | sort -k2,2) "$UNIGRAMS" | svecawk -vU="$NUM_UNIGRAMS" -vB="$((NUM_UNIGRAMS * $1 - ($1*($1+1)/2)))" '{print $2,$1 "\t" $3/B/($4/U*($5/U))}'
	#log($3)-log(B)-((log($4)+log($5)-(2*log(U))))
	;;
    *)
	"$0" help
	;;
esac
