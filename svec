#!/bin/zsh

# TODO have a way to set precision of numeric output

aggregate() {
    awk -F'\t' -vOFS=$'\t' '{while (2<NF) {$2'"$1"'=$NF; NF--}; print}'
}

CMD="$1"
shift
case "$CMD" in
    add) #Element-wise sum of 2 or more vectors
	#<vector> [<vector>]
	"$0" join "$@" | aggregate "+"
	;;
    analogy) #Computes the analogy vector from 3 word2vec embeddings king:man::queen:woman => -king+man+queen=woman
	#<vector> <vector> <vector>
	"$0" add <("$0" negate "$1") "$2" "$3"
	;;
    cooccurrences) #Prints a 2D matrix of counts of token co-occurrence within a given window computed from a whitespace-separated file of tokens
	#<window> <file>
	tr -s '[:space:]' '\n' < "$2" | awk -vW="$1" '$1 { for (i=1;i<=W;i++) { if(c[i]) { if (c[i]<$0) { print c[i],$0 } else { print $0,c[i] }}; c[i]=c[i+1] }; c[W]=$0 }' | sort | uniq -c | sed -E 's/[[:space:]]*([[:digit:]]+) ([[:alnum:]]+) ([[:alnum:]]+)/\2 \3\t\1/'
	;;
    counts) #Prints a vector of counts from a newline-separated stream of tokens
	#<file>
	sort "$1" | uniq -c | sed -E 's/[[:space:]]*([[:digit:]]+) (.+)/\2\t\1/'
	;;
    dot)
	"$0" join "$@" | aggregate '*'
	;;
    detriangularize) #Computes a dense 2D matrix from a triangular matrix by copying values across the diagonal
	#<triangular matrix>
	awk '{print} $1!=$2 {print $2,$1"\t"$3}' "$1" | sort
	;;
    --help|-h|help) #Print the list of subcommands or help information for a specific subcommand (e.g. "svec help dot")
	#<subcommand>
	{[[ -z "$1" ]] && echo 'usage: svec <subcommand> [arguments]';
	 grep -A "${+1}" -- "$1.*)\s#" "$0" | sed -nE -e 's/\s*(.+)\)\s#(.+)$/\1 - \2/p' -e "s/^\s*#(.+)/usage: $1 \1/p"} | \
	    sed 's/^\s*//; 2,$ s/^/\t/'	
	;;
    join) #Concatenates numerical values with the same indices together for further processing (summation, multiplication, etc.)
	#<vector> [<vector>]
	if [[ $# -le 1 ]]; then
	    cat "$1"
	elif [[ $# -eq 2 ]]; then
	    join -a1 -a2 -e0 -t$'\t' "$1" "$2"
	else
	    "$0" join "$1" "$2" | {shift 2; "$0" join - "$@"}
	fi
	;;
    negate) #Negates a vector
	#<vector>
	"$0" scale -1 "$1"
	;;
    neighbors) #Accepts a 2D matrix and a vector and outputs a vector of cosine distances between the rows of the matrix and the input vector
	#<2D matrix> <vector>
	# need a join of the norm of input (scalar, no need to join), norm of each vector (vecnorm and join on row), then we join input with every set of columns (every row) and dot them, dividing at the end by the norms. so really we should start with the dots, join the vecnorm, and save the norm as a constant
	join -a1 -a2 -e0 -12 <(sort -k2,2 "$1") "$2" | aggregate "*"
	#join -a1 -a2 -e0 -12 "$1" "$2" | awk '{print $2,$1"\t"($3*$4)}' | awk '{v=$NF*$(NF-1); NF-=3; if (!d) d=$0; if (d!=$0) {printnorm(); d=$0; s=v} else s+=v} END {printnorm()} function printnorm(){ printf("%s\t%.50g\n",d,sqrt(s)); }' "$1"
	;;
    norm) #Computes the Euclidean norm of a vector, or an entry-wise Euclidean norm of a matrix
	#<vector>
	awk '{n+=$NF*$NF} END {print sqrt(n)}' "$1"
	;;
    scale) #Scale all elements by a constant
	#<constant> <vector>
	awk -F'\t' -vOFS='\t' '{$2*=('"$1"'); print}' "$2"
	;;
    sum) #Sums all elements and returns a constant
	#<vector>
	awk '{n+=$NF} END {print n}' "$1"
	;;
    vecnorm) #Eliminates the rightmost dimension of a matrix and computes the Euclidean norms to use as values for the remaining indices
	#<matrix>
	awk '{v=$NF; NF-=2; if (!d) d=$0; if (d!=$0) {printnorm(); d=$0; s=v*v} else s+=v*v} END {printnorm()} function printnorm(){ printf("%s\t%.50g\n",d,sqrt(s)); }' "$1"
	;;
    word2vec) #Computes matrix of log pointwise mutual information scores from the co occurrence matrix of a stream of whitespace-separated tokens that approximates word2vec embeddings
	#<co-occurrence window size> <token file>
	local BIGRAMS=$(mktemp) UNIGRAMS=$(mktemp)
	trap "rm -f $UNIGRAMS $BIGRAMS" EXIT
	local NUM_UNIGRAMS=$(tr -s '[:space:]' '\n' < "$2" | awk -vW="$1" -vUs="$0 counts ->$UNIGRAMS" -vBs="$0 counts ->$BIGRAMS" '{print | Us; for (i=1;i<=W;i++) { if(c[i]) { print (c[i]<$0) ? c[i]" "$0 : $0" "c[i] | Bs }; c[i]=c[i+1] }; c[W]=$0 } END {print NR}')
	join -12 <(join "$BIGRAMS" "$UNIGRAMS" | sort -k2,2) "$UNIGRAMS" | awk -M -vU="$NUM_UNIGRAMS" -vB="$((NUM_UNIGRAMS * $1 - ($1*($1+1)/2)))" '{printf("%s %s\t%.50g\n",$2,$1,$3/B/($4/U*($5/U)))}'
	#log($3)-log(B)-((log($4)+log($5)-(2*log(U))))
	;;
    *)
	"$0" help
	;;
esac
